# 4.1 Undirected Graphs

Our starting point is the study of graph models where edges are nothing more than connections between vertices. We use the term **undirected graph** in contexts where we need to distinguish this model from other models.

A **graph** is a set of **vertices** and a collection of **edges** that each connect a pair of vertices.

By convention, we use the names 0 through V-1 for the vertices in a V-**vertex** graph.

We use the notation **v-w** to refer to an edge that connects v and w.

A **drawing** gives us intuition about the structure of the graph; but a graph can be drawn in different ways.

{% hint style="info" %}
Mathematicians sometimes refer to graphs with parallel edges as multigraphs and graphs with no **parallel edges** or **self-loops** as simple graphs.
{% endhint %}

When there is an edge connecting two vertices, we say that the vertices are **adjacent** to one another and that the edge is **incident** to both vertices. The **degree** of a vertex is the number of edges incident to it. A **subgraph** is a subset of a graph’s edges \(and associated vertices\) that constitutes a graph.

A path in a graph is a sequence of vertices connected by edges. A **simple path** is one with no repeated vertices. A cycle is a path with at least one edge whose first and last vertices are the same. A **simple cycle** is a cycle with no repeated edges or vertices \(except the requisite repetition of the first and last vertices\). The **length** of a path or a cycle is its number of edges.

{% hint style="info" %}
Most often, we work with simple cycles and simple paths and drop the _simple_ modifier.
{% endhint %}

We say that one vertex is **connected** to another if there exists a path that contains both of them. A graph is **connected** if there is a path from every vertex to every other vertex in the graph.

An **acyclic** graph is a graph with no cycles. A **tree** is an acyclic connected graph. A disjoint set of trees is called a **forest**. 

## Representation

The standard graph representation for graphs that are not dense is called the **adjacency-lists** data structure, where we keep track of all the vertices adjacent to each vertex on a **linked list** \(**Bag** ADT\)that is associated with that vertex. We maintain an **array** of lists so that, given a vertex, we can immediately access its list.

To add an edge connecting v and w, we add w to v’s adjacency list and v to w’s adjacency list. Thus, each edge appears **twice** in the data structure.

```java
public class Graph {
    private final int V; //the number of vertices
    private int E; // by the number of edges
    private Bag<Integer>[] adj; //adjacency-lists
}
```

## Depth-first search

A classic recursive method for searching in a connected graph \(visiting all of its vertices and edges\) is called depth-first search \(DFS\). 

The **DepthFirstSearch** class represents a data type for determining the vertices connected to a given source vertex.

```java
public class DepthFirstSearch {
    private boolean[] marked;    // marked[v] = is there an s-v path?
    private int count;           // number of vertices connected to s
    public DepthFirstSearch(Graph G, int s) {
        // Computes the vertices in graph G 
        // that are connected to the source vertex s.
    }
}
```

It follows the graph’s edges _to find the vertices connected to the source_.

```java
private void dfs(Graph G, int v) {
    marked[v] = true; // mark the starting point as visited
    count++;
    for (int w : G.adj(v))
       if (!marked[w]) dfs(G, w);
}
```

### Finding Paths

The **single-source paths** problem is fundamental to graph processing: Is there a path from s to a given target vertex v? If so, find such a path.

To solve the problem, in accordance with our standard design pattern, we use the following API:

```java
public class DepthFirstPaths {
    private boolean[] marked;    // marked[v] = is there an s-v path?
    private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
    private final int s;         // source vertex
}
```

Instead of just keeping track of the path from the **current** vertex back to the start, we remember a path from **each** vertex to the start. To accomplish this, we remember the edge v-w that takes us to each vertex w for the first time, by setting edgeTo\[w\] to v.

### Cycle detection

Is a given graph acylic?  The **Cycle** class represents a data type for determining whether an undirected graph has a simple cycle.

```java
public class Cycle {
    private boolean[] marked;
    
    public Cycle(Graph G) {
        marked = new boolean[G.V()];
        for (int s = 0; s < G.V(); s++)
            if (!marked[s])
                dfs(G, s, s);
    }
    
    private void dfs(Graph G, int u, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) { dfs(G, v, w); }
            else if (w != u) { hasCycle = true }
        }
    }
}
```

## Breadth-first search

**Single-source shortest paths**: Given a graph and a source vertex s, Is there a path from s to a given target vertex v? If so, find a shortest such path.

The **BreadthFirstPaths** class represents a data type for finding shortest paths \(number of edges\) from a source vertex.

```java
public class BreadthFirstPaths {
    private boolean[] marked;  // marked[v] = is there an s-v path
    private int[] edgeTo;      // edgeTo[v] = previous edge on shortest s-v path
    private int[] distTo;      // distTo[v] = number of edges shortest s-v path
}
```

To find a shortest path from s to v, we start at s and check for v among all the vertices that we can reach by following **one edge**, then we check for v among all the vertices that we can reach from s by following **two edges**, and so forth.

```java
private void bfs(Graph G, int s) {
    Queue<Integer> q = new Queue<Integer>();
    for (int v = 0; v < G.V(); v++)
        marked[s] = true;
        q.enqueue(s);
        while (!q.isEmpty()) {
        int v = q.dequeue();
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                marked[w] = true;
                q.enqueue(w);
            }
        }
    }
}
```

