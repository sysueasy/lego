# 2.2 Mergesort

Idea: combining two ordered arrays to make one larger ordered array. To sort an array, divide it into two halves, sort the two halves \(recursively\), and then merge the results.

```java
private static void sort(int[] a) {
    int[] aux = new int[a.length];
    sort(a, aux, 0, a.length-1);
}
    
private static void sort(int[] a, int[] aux, int lo, int hi) {
    if (hi<=lo) return; // boundary
    int mid = lo + (hi-lo)/2; // mid index
    sort(a, aux, lo, mid); // sort the first half
    sort(a, aux, mid+1, hi); // sort the second half
    merge(a, aux, lo, mid, hi); // merge
}
    
private static void merge(int[] a, int[] aux, int lo, int mid, int hi) {
    // copy to auxiliary
    for (int k=lo; k<=hi; k++) {
        aux[k] = a[k];
    }
        
    int i=lo, j=mid+1;
    // merge back to a[]
    for (int k=lo; k<=hi; k++) {
        if (i>mid) a[k] = aux[j++]; // left exhauseted, pick from right
        else if (j>hi) a[k] = aux[i++]; // right exhauseted, pick from left
        else if (aux[i]<aux[j]) a[k]=aux[i++];
        else a[k]=aux[j++];
    }
}
```

**Computational complexity**: It guarantees to sort any array of N items in time proportional to NlogN. Its prime disadvantage is that it uses extra space proportional to N. Actually, no sorting algorithm can guarantee to use fewer than **~NlogN** compares.

