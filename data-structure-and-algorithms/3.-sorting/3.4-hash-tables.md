# 3.4 Hash Tables

If keys are small integers, we can use an array to implement an unordered symbol table, by interpreting the key as an array index, ready for immediate access. In this section, we consider **hashing**, an extension of this simple method that handles more complicated types of keys.

Search algorithms that use hashing consist of two separate parts. The first part is to compute a **hash function** that transforms the search key into an array index. Ideally, different keys would map to different indices. This ideal is generally beyond our reach, so we have to face the possibility that two or more different keys may hash to the same array index. Thus, the second part of a hashing search is a **collision-resolution** process: **separate chaining** and **linear probing**.

## Hash functions

If we have an array that can hold M key-value pairs, then we need a hash function that can transform any given key into an index into that array: an integer in the range \[0, Mâ€“1\].

To hash positive integers: **modular hashing**. Choose the array size M to be **prime** and, for any positive integer key k, compute the remainder when dividing k by M.

Java helps us address the basic problem that every type of data needs a hash function by ensuring that every data type inherits a method called _hashCode\(\)_ that returns a 32-bit integer.

You must override both hashCode\(\) and equals\(\) if you need to hash with a user-defined type. Java provides hashCode\(\) implementations that override the defaults for many common types \(including String, Integer, Double, File, and URL\).





